"""
BTF (Body-to-Fabric) Parameter Generator

Generates Optitex batch commands from body measurements.
Supports multiple output formats:
- Format A: Text file with @PARAMS
- Format B: Excel/CSV for @MTM_CREATE
- Format C: Direct @MVPNT commands (primary)
"""

from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass
import logging

from .template_config import get_template, TemplateConfig

logger = logging.getLogger(__name__)


class BTFGeneratorError(Exception):
    """Raised when BTF generation fails."""

    pass


@dataclass
class BTFResult:
    """Result of BTF generation."""

    format_a_path: Optional[Path]  # Text file
    format_b_path: Optional[Path]  # Excel/CSV
    format_c_commands: List[str]  # Direct commands
    validation_errors: List[str]


class BTFGenerator:
    """Generate BTF parameters for Optitex."""

    def __init__(self, output_dir: Path):
        """
        Initialize BTF generator.

        Args:
            output_dir: Directory to save parameter files
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_all_formats(
        self, measurements: Dict[str, float], template_name: str, order_id: str
    ) -> BTFResult:
        """
        Generate BTF parameters in all three formats.

        Args:
            measurements: Body measurements from scan
            template_name: Name of template to use
            order_id: Order identifier

        Returns:
            BTFResult with all three formats
        """
        template = get_template(template_name)

        # Validate measurements
        validation_errors = self._validate_measurements(measurements, template)
        if validation_errors:
            logger.warning(f"Measurement validation issues: {validation_errors}")

        # Generate all three formats
        format_a_path = self._generate_format_a(measurements, template, order_id)
        format_b_path = self._generate_format_b(measurements, template, order_id)
        format_c_commands = self._generate_format_c(measurements, template, order_id)

        return BTFResult(
            format_a_path=format_a_path,
            format_b_path=format_b_path,
            format_c_commands=format_c_commands,
            validation_errors=validation_errors,
        )

    def _validate_measurements(
        self, measurements: Dict[str, float], template: TemplateConfig
    ) -> List[str]:
        """Validate measurements against template requirements."""
        errors = []

        # Check all required measurements are present
        for measurement in template.measurement_mapping.keys():
            if measurement not in measurements:
                errors.append(f"Missing required measurement: {measurement}")

        # Check measurement ranges
        for key, value in measurements.items():
            if value <= 0:
                errors.append(f"Invalid measurement {key}: {value} (must be > 0)")
            elif value > 200:  # Unlikely to have measurements > 200cm
                errors.append(f"Suspicious measurement {key}: {value}cm (verify)")

        # Check body proportion rules
        if "waist_girth" in measurements and "chest_girth" in measurements:
            if measurements["waist_girth"] > measurements["chest_girth"] * 1.2:
                errors.append("Waist > 120% of chest - verify measurements")

        return errors

    def _generate_format_a(
        self, measurements: Dict[str, float], template: TemplateConfig, order_id: str
    ) -> Path:
        """
        Generate Format A: Text file with @PARAMS.

        Format:
            HALF_CHEST=52.0
            HALF_WAIST=46.0
            ...
        """
        output_path = self.output_dir / f"{order_id}_params.txt"

        lines = [
            f"# BTF Parameters for {template.name}",
            f"# Order: {order_id}",
            f"# Generated by Black Box POC",
            "",
        ]

        # Add measurements
        for key, value in measurements.items():
            lines.append(f"{key.upper()}={value:.2f}")

        # Add calculated values
        if "chest_girth" in measurements:
            lines.append(f"HALF_CHEST={measurements['chest_girth'] / 2:.2f}")
        if "waist_girth" in measurements:
            lines.append(f"HALF_WAIST={measurements['waist_girth'] / 2:.2f}")
        if "hip_girth" in measurements:
            lines.append(f"HALF_HIP={measurements['hip_girth'] / 2:.2f}")

        output_path.write_text("\n".join(lines), encoding="utf-8")
        logger.info(f"Generated Format A (text): {output_path}")

        return output_path

    def _generate_format_b(
        self, measurements: Dict[str, float], template: TemplateConfig, order_id: str
    ) -> Optional[Path]:
        """
        Generate Format B: CSV for @MTM_CREATE.

        Format:
            Measurement,Value,Unit
            Chest Girth,102.0,cm
            Waist Girth,88.0,cm
            ...
        """
        try:
            output_path = self.output_dir / f"{order_id}_measurements.csv"

            lines = ["Measurement,Value,Unit"]

            measurement_names = {
                "chest_girth": "Chest Girth",
                "waist_girth": "Waist Girth",
                "hip_girth": "Hip Girth",
                "shoulder_width": "Shoulder Width",
                "arm_length": "Arm Length",
                "inseam": "Inseam",
                "neck_girth": "Neck Girth",
                "wrist_girth": "Wrist Girth",
                "bicep_girth": "Bicep Girth",
                "thigh_girth": "Thigh Girth",
                "knee_girth": "Knee Girth",
                "calf_girth": "Calf Girth",
            }

            for key, value in measurements.items():
                name = measurement_names.get(key, key.replace("_", " ").title())
                lines.append(f"{name},{value:.2f},cm")

            output_path.write_text("\n".join(lines), encoding="utf-8")
            logger.info(f"Generated Format B (CSV): {output_path}")

            return output_path

        except Exception as e:
            logger.error(f"Failed to generate Format B: {e}")
            return None

    def _generate_format_c(
        self, measurements: Dict[str, float], template: TemplateConfig, order_id: str
    ) -> List[str]:
        """
        Generate Format C: Direct @MVPNT commands.

        This is the primary format - most control and precision.

        Commands:
            @REM Apply measurements for Order: {order_id}
            @MVPNT FP_CHEST /X={value} /Y={value}
            ...
        """
        commands = [
            f"@REM BTF Direct Commands for {template.name}",
            f"@REM Order: {order_id}",
            f"@REM Generated by Black Box POC",
            "",
            "@REM Apply body measurements to pattern points",
        ]

        # Generate point movement commands
        for body_measurement, point_configs in template.measurement_mapping.items():
            if body_measurement not in measurements:
                continue

            body_value = measurements[body_measurement]

            for point_name, adjustment_type, factor in point_configs:
                if adjustment_type == "move_x":
                    delta_x = body_value * factor
                    commands.append(f"@MVPNT {point_name} /X={delta_x:.2f}")

                elif adjustment_type == "move_y":
                    delta_y = body_value * factor
                    commands.append(f"@MVPNT {point_name} /Y={delta_y:.2f}")

                elif adjustment_type == "scale_x":
                    # Scale relative to base size (assumed size 50)
                    base_value = self._get_base_value(point_name)
                    scale_factor = (body_value * factor) / base_value
                    commands.append(
                        f"@SCALE {point_name} /X={scale_factor:.4f} /RELATIVE=YES"
                    )

                elif adjustment_type == "scale_y":
                    base_value = self._get_base_value(point_name)
                    scale_factor = (body_value * factor) / base_value
                    commands.append(
                        f"@SCALE {point_name} /Y={scale_factor:.4f} /RELATIVE=YES"
                    )

        commands.append("")  # Empty line at end
        logger.info(f"Generated Format C (direct commands): {len(commands)} commands")

        return commands

    def _get_base_value(self, point_name: str) -> float:
        """Get base measurement value for a point (size 50 reference)."""
        # These are approximate base values for size 50
        base_values = {
            "FP_CHEST": 52.0,
            "BP_CHEST": 52.0,
            "FP_WAIST": 46.0,
            "BP_WAIST": 46.0,
            "FP_HIP": 49.0,
            "BP_HIP": 49.0,
            "FP_SHOULDER": 46.0,
            "BP_SHOULDER": 46.0,
            "SLV_HEM": 64.0,
            "FP_HEM": 44.0,
            "BP_HEM": 44.0,
            "FP_NECK": 40.0,
            "BP_NECK": 40.0,
            "SLV_CUFF": 17.5,
            "FP_THIGH": 58.0,
            "BP_THIGH": 58.0,
            "FP_KNEE": 40.0,
            "BP_KNEE": 40.0,
            "LEG_HEM": 82.0,
            "FP_CALF": 38.0,
            "BP_CALF": 38.0,
        }
        return base_values.get(point_name, 50.0)  # Default to 50.0 if unknown


def generate_btf_parameters(
    measurements: Dict[str, float], template_name: str, order_id: str, output_dir: Path
) -> BTFResult:
    """
    Convenience function to generate BTF parameters.

    Args:
        measurements: Body measurements from scan
        template_name: Template to use (basic_tee, woven_shirt, skinny_trousers)
        order_id: Order identifier
        output_dir: Directory to save files

    Returns:
        BTFResult with all three formats
    """
    generator = BTFGenerator(output_dir)
    return generator.generate_all_formats(measurements, template_name, order_id)
